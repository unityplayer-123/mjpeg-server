<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>MJPEG Viewer</title>
</head>

<body style="margin:0; background:black;">
<img id="stream" style="width:100vw; height:100vh; object-fit:contain;">

<canvas id="canvas" style="display:none;"></canvas>

<script>
const img = document.getElementById("stream");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// ====== 1) MJPEGは「貼りっぱなし」 ======
function connectStream() {
  // cache busting しつつ接続（1回だけ）
  img.src = `/screen?t=${Date.now()}`;
  console.log("MJPEG CONNECT");
}
connectStream();

// エラー時は再接続
img.addEventListener("error", () => {
  console.warn("MJPEG error -> reconnect");
  setTimeout(connectStream, 1000);
});

// 保険：一定時間ごとに張り直し（プロキシ切断対策）
setInterval(() => {
  console.log("MJPEG refresh reconnect");
  connectStream();
}, 30000);

// ====== 2) 保存タイミング制御（任意） ======
let saving = false;

// 5秒後に保存開始
setTimeout(() => {
  saving = true;
  console.log("SAVE START");

  // 10秒後に保存終了（映像配信は止めない）
  setTimeout(() => {
    saving = false;
    console.log("SAVE END (stream continues)");
  }, 10000);

}, 5000);

// ====== 3) PNG保存ループ（保存中だけ） ======
async function captureLoop() {
  try {
    if (saving && img.complete && img.naturalWidth > 0) {
      const res = await fetch("/latest-id", { cache: "no-store" });
      const data = await res.json();
      const frameId = data.frameId;

      if (frameId) {
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        ctx.drawImage(img, 0, 0);

        canvas.toBlob(blob => {
          if (!blob) return;
          fetch(`/save-frame?id=${frameId}`, {
            method: "POST",
            headers: { "Content-Type": "image/png" },
            body: blob
          });
        }, "image/png");
      }
    }
  } catch (e) {
    console.warn("captureLoop error:", e);
  }

  requestAnimationFrame(captureLoop);
}
captureLoop();
</script>
</body>
</html>
